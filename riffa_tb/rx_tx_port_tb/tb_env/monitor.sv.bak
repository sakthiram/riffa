class sg_list_packet;

  bit [63:0] addr;
  bit [31:0] len;

endclass: sg_list_packet 

class wr_monitor extends uvm_monitor;

    `uvm_component_utils(wr_monitor)

    string fifo_type;
    uvm_analysis_port#(sg_list_packet) sg_wr_ap;
    
    virtual top_if dut_vif;

    function new(string name, uvm_component parent);
       super.new(name, parent);
    endfunction: new

    function void build_phase(uvm_phase phase);
      // Get interface reference from config database
      if(!uvm_config_db#(virtual top_if)::get(this, "", "dut_vif", dut_vif)) begin
        `uvm_error("", "uvm_config_db::get failed")
      end
      sg_wr_ap = new(.name("sg_wr_ap"), .parent(this));
    endfunction

    task run_phase(uvm_phase phase);
       bit [3*32+`DATA_WIDTH-1:0] circular_buffer; // since max of {7/11} DW outstanding is possible for {128/256} 
       bit [2:0] c_buf_pos_start = 0;
       bit [2:0] c_buf_pos_end = 0;

       forever begin
          sg_list_packet sg_pkt;
          int word_count = 0;
          int size = 0, start_point = c_buf_pos_start;
          sg_pkt = new();

          // SG_RX
          if (fifo_type == "SG_RX") begin

            while(dut_vif.SG_RX_DATA_EN == 0) @dut_vif.CLK;
            // Append to circular_buffer
            while (word_count < dut_vif.SG_RX_DATA_EN) begin
                circular_buffer[c_buf_pos_end*32 +: 31] = dut_vif.SG_RX_DATA[(word_count+1)*32-1:word_count*32];
                c_buf_pos_end = (c_buf_pos_end+1)%(3+`DATA_WIDTH/32);
                word_count += 1;
            end
            // Circular Buffer Size Calc
            while (start_point != c_buf_pos_end) begin
                start_point = (start_point + 1)%(3+`DATA_WIDTH/32);
                size += 1;
            end
            // Add to pkt analysis port if 4 DW availble
            if (size >= 4) begin
                sg_pkt.addr[31:0] = circular_buffer[(c_buf_pos_start+1)*32-1:c_buf_pos_start*32];
                c_buf_pos_start = (c_buf_pos_start + 1)%(3+`DATA_WIDTH/32);
                sg_pkt.addr[63:32] = circular_buffer[(c_buf_pos_start+1)*32-1:c_buf_pos_start*32];
                c_buf_pos_start = (c_buf_pos_start + 1)%(3+`DATA_WIDTH/32);
                sg_pkt.len = circular_buffer[(c_buf_pos_start+1)*32-1:c_buf_pos_start*32];
                c_buf_pos_start = (c_buf_pos_start + 2)%(3+`DATA_WIDTH/32);
                sg_wr_ap.write(sg_pkt);
            end

          end

          // SG_TX

      
      end // forever
    endtask: run_phase


endclass: wr_monitor

class sg_wr_sb_subscriber extends uvm_subscriber#(sg_list_packet);
   `uvm_component_utils(sg_wr_sb_subscriber)
 
   function new(string name, uvm_component parent);
      super.new(name, parent);
   endfunction: new
 
   function void write(sg_list_packet sg_pkt);
     uvm_table_printer p = new;
     `uvm_info("sg_wr_sb_subscriber",
                       { "Writing sg_packet.\n", sg_pkt.sprint(p) }, UVM_LOW);       
   endfunction: write
endclass: sg_wr_sb_subscriber 

class rd_monitor extends uvm_monitor;

    `uvm_component_utils(rd_monitor)

    string fifo_type;
    uvm_analysis_port#(sg_list_packet) sg_rd_ap;
    
    virtual top_if dut_vif;

    function new(string name, uvm_component parent);
       super.new(name, parent);
    endfunction: new

    function void build_phase(uvm_phase phase);
      // Get interface reference from config database
      if(!uvm_config_db#(virtual top_if)::get(this, "", "dut_vif", dut_vif)) begin
        `uvm_error("", "uvm_config_db::get failed")
      end
      sg_rd_ap = new(.name("sg_rd_ap"), .parent(this));
    endfunction

    task run_phase(uvm_phase phase);
       forever begin
          sg_list_packet sg_pkt;
          logic ren;
          sg_pkt = new();
          //sg_pkt = sg_list_packet::type_id::create("sg_pkt");

          // SG_RX
          if (fifo_type == "SG_RX") begin
            @dut_vif.CLK;
            uvm_hdl_read("tb_top.dut.rxPort.wSgElemRen", ren);
            while(ren == 0) begin
                @dut_vif.CLK;
                uvm_hdl_read("tb_top.dut.rxPort.wSgElemRen", ren);
            end

            uvm_hdl_read("tb_top.dut.rxPort.wSgElemAddr", sg_pkt.addr);
            uvm_hdl_read("tb_top.dut.rxPort.wSgElemLen", sg_pkt.len);
                sg_rd_ap.write(sg_pkt);
          end

          // SG_TX

      
      end // forever
    endtask: run_phase


endclass: rd_monitor

class sg_rd_sb_subscriber extends uvm_subscriber#(sg_list_packet);
   `uvm_component_utils(sg_rd_sb_subscriber)
 
   function new(string name, uvm_component parent);
      super.new(name, parent);
   endfunction: new
 
   function void write(sg_list_packet sg_pkt);
     uvm_table_printer p = new;
     `uvm_info("sg_rd_sb_subscriber",
                       { "Reading sg_packet.\n", sg_pkt.sprint(p) }, UVM_LOW);       
   endfunction: write
endclass: sg_rd_sb_subscriber 

